{"ast":null,"code":"var _jsxFileName = \"/home/n/semantic_map_ui/src/App.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\n\n/* ===== MAP PARAMS ===== */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_SIZE = 7;\nconst GRID_COLS = 145;\nconst GRID_ROWS = 102;\nconst MAP_WIDTH = GRID_COLS * GRID_SIZE;\nconst MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\nfunction App() {\n  _s();\n  const [mode, setMode] = useState('place');\n  const [gridMap, setGridMap] = useState({});\n  const [cornerPoints, setCornerPoints] = useState([]);\n  const [selectedCells, setSelectedCells] = useState([]);\n\n  /* ===== JSON LOAD ===== */\n  useEffect(() => {\n    fetch('/semantic_grid_map.json').then(res => res.ok ? res.json() : null).then(data => {\n      if (data !== null && data !== void 0 && data.grid) {\n        setGridMap(data.grid);\n      } else {\n        const grid = createInitialGrid({\n          cols: 145,\n          rows: 102,\n          spacing: 0.1,\n          leftTop: {\n            x: -5.5,\n            y: 5.5\n          }\n        });\n        setGridMap(grid);\n      }\n    }).catch(() => {\n      const grid = createInitialGrid({\n        cols: 145,\n        rows: 102,\n        spacing: 0.1,\n        leftTop: {\n          x: -5.5,\n          y: 5.5\n        }\n      });\n      setGridMap(grid);\n    });\n  }, []);\n  const createInitialGrid = ({\n    cols,\n    rows,\n    spacing,\n    leftTop\n  }) => {\n    const grid = {};\n    for (let gx = 0; gx < cols; gx++) {\n      for (let gy = 0; gy < rows; gy++) {\n        const wx = leftTop.x + gx * spacing;\n        const wy = leftTop.y - gy * spacing;\n        const key = `${gx},${gy}`;\n        grid[key] = {\n          places: [],\n          objects: [],\n          robots: [],\n          explicit: {\n            grid: {\n              x: gx,\n              y: gy\n            },\n            world: {\n              x: Number(wx.toFixed(3)),\n              y: Number(wy.toFixed(3))\n            }\n          }\n        };\n      }\n    }\n    return grid;\n  };\n\n  /* ===== MAP CLICK (4 POINTS ONLY) ===== */\n  const handleMapClick = e => {\n    const rect = e.currentTarget.getBoundingClientRect();\n    const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n    const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n    setCornerPoints(prev => {\n      // ✅ 마지막 점 다시 클릭 → pop\n      if (prev.length > 0 && prev[prev.length - 1].x === gx && prev[prev.length - 1].y === gy) {\n        return prev.slice(0, -1);\n      }\n\n      // ✅ 이미 4개면 더 안 찍힘\n      if (prev.length >= 4) return prev;\n\n      // ✅ 새 점 추가\n      return [...prev, {\n        x: gx,\n        y: gy\n      }];\n    });\n  };\n\n  /* ===== WHEN 4 POINTS SELECTED → AUTO SELECT AREA ===== */\n  useEffect(() => {\n    if (cornerPoints.length !== 4) return;\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n    const cells = [];\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        cells.push({\n          x,\n          y\n        });\n      }\n    }\n    setSelectedCells(cells);\n  }, [cornerPoints]);\n\n  /* ===== APPLY (PLACE / OBJECT) ===== */\n  const applyToSelected = () => {\n    if (cornerPoints.length !== 4 || selectedCells.length === 0) {\n      alert('점 4개를 먼저 찍어라');\n      return;\n    }\n    const name = prompt(mode === 'place' ? 'place name?' : 'object id?');\n    const type = mode === 'object' ? prompt('object type?') : 'place';\n    const relation = prompt('relation?');\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n    const center = {\n      x: (Math.min(...xs) + Math.max(...xs)) / 2,\n      y: (Math.min(...ys) + Math.max(...ys)) / 2\n    };\n    setGridMap(prev => {\n      const updated = {\n        ...prev\n      };\n      selectedCells.forEach(({\n        x,\n        y\n      }) => {\n        const key = `${x},${y}`;\n        const cell = updated[key] || {\n          places: [],\n          objects: [],\n          robots: []\n        };\n        if (mode === 'place') {\n          cell.places = [{\n            id: name,\n            type: 'place',\n            explicit: {\n              grid: center\n            },\n            implicit: {\n              relation: relation || 'none'\n            },\n            symbolic: {\n              label: name\n            }\n          }];\n        } else {\n          cell.objects = [{\n            id: name,\n            type,\n            explicit: {\n              grid: center\n            },\n            implicit: {\n              relation: relation || 'none'\n            },\n            symbolic: {\n              label: type\n            }\n          }];\n        }\n        updated[key] = cell;\n      });\n      return updated;\n    });\n    setCornerPoints([]);\n    setSelectedCells([]);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      display: 'flex'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        width: MAP_WIDTH,\n        height: MAP_HEIGHT,\n        backgroundImage: \"url('/map.png')\",\n        backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n        position: 'relative',\n        border: '1px solid black'\n      },\n      onClick: handleMapClick,\n      children: [[...Array(GRID_COLS + 1)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: i * GRID_SIZE,\n          top: 0,\n          width: 1,\n          height: '100%',\n          background: 'rgba(0,0,0,0.2)'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 21\n      }, this)), [...Array(GRID_ROWS + 1)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: i * GRID_SIZE,\n          left: 0,\n          height: 1,\n          width: '100%',\n          background: 'rgba(0,0,0,0.2)'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 209,\n        columnNumber: 21\n      }, this)), selectedCells.map(({\n        x,\n        y\n      }) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: x * GRID_SIZE,\n          top: y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: 'rgba(0,0,255,0.3)',\n          pointerEvents: 'none'\n        }\n      }, `${x},${y}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 21\n      }, this)), cornerPoints.map((p, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: p.x * GRID_SIZE,\n          top: p.y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: 'rgba(255,0,0,0.7)',\n          pointerEvents: 'none'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 240,\n        columnNumber: 21\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 183,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginLeft: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Mode\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setMode('place'),\n        children: \"Place\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 258,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setMode('object'),\n        children: \"Object\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 259,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"\\uC810 \", cornerPoints.length, \" / 4 \\uC120\\uD0DD\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 261,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: applyToSelected,\n        children: \"Apply to Selected Cells\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 263,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        style: {\n          height: 600,\n          overflow: 'auto'\n        },\n        children: JSON.stringify({\n          grid: gridMap\n        }, null, 2)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 181,\n    columnNumber: 9\n  }, this);\n}\n_s(App, \"ghD6mf40iX/1vNPA1r/3Mne33z0=\");\n_c = App;\nexport default App;\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 5;\n// const GRID_COLS = 145; // 가로\n// const GRID_ROWS = 102; // 세로\n\n// const MAP_WIDTH = GRID_COLS * GRID_SIZE;\n// const MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK ===== */\n//     const handleGridClick = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             const exists = prev.some((c) => c.x === gx && c.y === gy);\n//             return exists\n//                 ? prev.filter((c) => !(c.x === gx && c.y === gy))\n//                 : [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_WIDTH,\n//                     height: MAP_HEIGHT,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true;\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COLS + 1)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {[...Array(GRID_ROWS + 1)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n//                     const place = val.places[0];\n//                     const hasObject = val.objects && val.objects.length > 0;\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n//                     if (place.id === 'path') bgColor = 'rgba(0,255,0,0.25)';\n//                     else if (hasObject || place.id === 'wall')\n//                         bgColor = 'rgba(255,0,0,0.25)';\n//                     else bgColor = 'rgba(255,255,0,0.35)';\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* PANEL */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useState","jsxDEV","_jsxDEV","GRID_SIZE","GRID_COLS","GRID_ROWS","MAP_WIDTH","MAP_HEIGHT","App","_s","mode","setMode","gridMap","setGridMap","cornerPoints","setCornerPoints","selectedCells","setSelectedCells","fetch","then","res","ok","json","data","grid","createInitialGrid","cols","rows","spacing","leftTop","x","y","catch","gx","gy","wx","wy","key","places","objects","robots","explicit","world","Number","toFixed","handleMapClick","e","rect","currentTarget","getBoundingClientRect","Math","floor","clientX","left","clientY","top","prev","length","slice","xs","map","p","ys","minX","min","maxX","max","minY","maxY","cells","push","applyToSelected","alert","name","prompt","type","relation","center","updated","forEach","cell","id","implicit","symbolic","label","style","display","children","width","height","backgroundImage","backgroundSize","position","border","onClick","Array","_","i","background","fileName","_jsxFileName","lineNumber","columnNumber","pointerEvents","marginLeft","overflow","JSON","stringify","_c","$RefreshReg$"],"sources":["/home/n/semantic_map_ui/src/App.js"],"sourcesContent":["import { useEffect, useState } from 'react';\n\n/* ===== MAP PARAMS ===== */\nconst GRID_SIZE = 7;\nconst GRID_COLS = 145;\nconst GRID_ROWS = 102;\n\nconst MAP_WIDTH = GRID_COLS * GRID_SIZE;\nconst MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\nfunction App() {\n    const [mode, setMode] = useState('place');\n    const [gridMap, setGridMap] = useState({});\n    const [cornerPoints, setCornerPoints] = useState([]);\n    const [selectedCells, setSelectedCells] = useState([]);\n\n    /* ===== JSON LOAD ===== */\n    useEffect(() => {\n        fetch('/semantic_grid_map.json')\n            .then((res) => (res.ok ? res.json() : null))\n            .then((data) => {\n                if (data?.grid) {\n                    setGridMap(data.grid);\n                } else {\n                    const grid = createInitialGrid({\n                        cols: 145,\n                        rows: 102,\n                        spacing: 0.1,\n                        leftTop: { x: -5.5, y: 5.5 },\n                    });\n                    setGridMap(grid);\n                }\n            })\n            .catch(() => {\n                const grid = createInitialGrid({\n                    cols: 145,\n                    rows: 102,\n                    spacing: 0.1,\n                    leftTop: { x: -5.5, y: 5.5 },\n                });\n                setGridMap(grid);\n            });\n    }, []);\n\n    const createInitialGrid = ({ cols, rows, spacing, leftTop }) => {\n        const grid = {};\n\n        for (let gx = 0; gx < cols; gx++) {\n            for (let gy = 0; gy < rows; gy++) {\n                const wx = leftTop.x + gx * spacing;\n                const wy = leftTop.y - gy * spacing;\n\n                const key = `${gx},${gy}`;\n                grid[key] = {\n                    places: [],\n                    objects: [],\n                    robots: [],\n                    explicit: {\n                        grid: { x: gx, y: gy },\n                        world: {\n                            x: Number(wx.toFixed(3)),\n                            y: Number(wy.toFixed(3)),\n                        },\n                    },\n                };\n            }\n        }\n\n        return grid;\n    };\n\n    /* ===== MAP CLICK (4 POINTS ONLY) ===== */\n    const handleMapClick = (e) => {\n        const rect = e.currentTarget.getBoundingClientRect();\n        const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n        const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n        setCornerPoints((prev) => {\n            // ✅ 마지막 점 다시 클릭 → pop\n            if (\n                prev.length > 0 &&\n                prev[prev.length - 1].x === gx &&\n                prev[prev.length - 1].y === gy\n            ) {\n                return prev.slice(0, -1);\n            }\n\n            // ✅ 이미 4개면 더 안 찍힘\n            if (prev.length >= 4) return prev;\n\n            // ✅ 새 점 추가\n            return [...prev, { x: gx, y: gy }];\n        });\n    };\n\n    /* ===== WHEN 4 POINTS SELECTED → AUTO SELECT AREA ===== */\n    useEffect(() => {\n        if (cornerPoints.length !== 4) return;\n\n        const xs = cornerPoints.map((p) => p.x);\n        const ys = cornerPoints.map((p) => p.y);\n\n        const minX = Math.min(...xs);\n        const maxX = Math.max(...xs);\n        const minY = Math.min(...ys);\n        const maxY = Math.max(...ys);\n\n        const cells = [];\n        for (let x = minX; x <= maxX; x++) {\n            for (let y = minY; y <= maxY; y++) {\n                cells.push({ x, y });\n            }\n        }\n\n        setSelectedCells(cells);\n    }, [cornerPoints]);\n\n    /* ===== APPLY (PLACE / OBJECT) ===== */\n    const applyToSelected = () => {\n        if (cornerPoints.length !== 4 || selectedCells.length === 0) {\n            alert('점 4개를 먼저 찍어라');\n            return;\n        }\n\n        const name = prompt(mode === 'place' ? 'place name?' : 'object id?');\n        const type = mode === 'object' ? prompt('object type?') : 'place';\n        const relation = prompt('relation?');\n\n        const xs = cornerPoints.map((p) => p.x);\n        const ys = cornerPoints.map((p) => p.y);\n\n        const center = {\n            x: (Math.min(...xs) + Math.max(...xs)) / 2,\n            y: (Math.min(...ys) + Math.max(...ys)) / 2,\n        };\n\n        setGridMap((prev) => {\n            const updated = { ...prev };\n\n            selectedCells.forEach(({ x, y }) => {\n                const key = `${x},${y}`;\n                const cell = updated[key] || {\n                    places: [],\n                    objects: [],\n                    robots: [],\n                };\n\n                if (mode === 'place') {\n                    cell.places = [\n                        {\n                            id: name,\n                            type: 'place',\n                            explicit: { grid: center },\n                            implicit: { relation: relation || 'none' },\n                            symbolic: { label: name },\n                        },\n                    ];\n                } else {\n                    cell.objects = [\n                        {\n                            id: name,\n                            type,\n                            explicit: { grid: center },\n                            implicit: { relation: relation || 'none' },\n                            symbolic: { label: type },\n                        },\n                    ];\n                }\n\n                updated[key] = cell;\n            });\n\n            return updated;\n        });\n\n        setCornerPoints([]);\n        setSelectedCells([]);\n    };\n\n    return (\n        <div style={{ display: 'flex' }}>\n            {/* MAP */}\n            <div\n                style={{\n                    width: MAP_WIDTH,\n                    height: MAP_HEIGHT,\n                    backgroundImage: \"url('/map.png')\",\n                    backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n                    position: 'relative',\n                    border: '1px solid black',\n                }}\n                onClick={handleMapClick}\n            >\n                {/* GRID */}\n                {[...Array(GRID_COLS + 1)].map((_, i) => (\n                    <div\n                        key={i}\n                        style={{\n                            position: 'absolute',\n                            left: i * GRID_SIZE,\n                            top: 0,\n                            width: 1,\n                            height: '100%',\n                            background: 'rgba(0,0,0,0.2)',\n                        }}\n                    />\n                ))}\n                {[...Array(GRID_ROWS + 1)].map((_, i) => (\n                    <div\n                        key={i}\n                        style={{\n                            position: 'absolute',\n                            top: i * GRID_SIZE,\n                            left: 0,\n                            height: 1,\n                            width: '100%',\n                            background: 'rgba(0,0,0,0.2)',\n                        }}\n                    />\n                ))}\n\n                {/* SELECTED AREA */}\n                {selectedCells.map(({ x, y }) => (\n                    <div\n                        key={`${x},${y}`}\n                        style={{\n                            position: 'absolute',\n                            left: x * GRID_SIZE,\n                            top: y * GRID_SIZE,\n                            width: GRID_SIZE,\n                            height: GRID_SIZE,\n                            background: 'rgba(0,0,255,0.3)',\n                            pointerEvents: 'none',\n                        }}\n                    />\n                ))}\n\n                {/* CORNER POINTS */}\n                {cornerPoints.map((p, i) => (\n                    <div\n                        key={i}\n                        style={{\n                            position: 'absolute',\n                            left: p.x * GRID_SIZE,\n                            top: p.y * GRID_SIZE,\n                            width: GRID_SIZE,\n                            height: GRID_SIZE,\n                            background: 'rgba(255,0,0,0.7)',\n                            pointerEvents: 'none',\n                        }}\n                    />\n                ))}\n            </div>\n\n            {/* PANEL */}\n            <div style={{ marginLeft: 20 }}>\n                <h3>Mode</h3>\n                <button onClick={() => setMode('place')}>Place</button>\n                <button onClick={() => setMode('object')}>Object</button>\n\n                <p>점 {cornerPoints.length} / 4 선택</p>\n\n                <button onClick={applyToSelected}>\n                    Apply to Selected Cells\n                </button>\n\n                <pre style={{ height: 600, overflow: 'auto' }}>\n                    {JSON.stringify({ grid: gridMap }, null, 2)}\n                </pre>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 5;\n// const GRID_COLS = 145; // 가로\n// const GRID_ROWS = 102; // 세로\n\n// const MAP_WIDTH = GRID_COLS * GRID_SIZE;\n// const MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK ===== */\n//     const handleGridClick = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             const exists = prev.some((c) => c.x === gx && c.y === gy);\n//             return exists\n//                 ? prev.filter((c) => !(c.x === gx && c.y === gy))\n//                 : [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_WIDTH,\n//                     height: MAP_HEIGHT,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true;\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COLS + 1)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {[...Array(GRID_ROWS + 1)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n//                     const place = val.places[0];\n//                     const hasObject = val.objects && val.objects.length > 0;\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n//                     if (place.id === 'path') bgColor = 'rgba(0,255,0,0.25)';\n//                     else if (hasObject || place.id === 'wall')\n//                         bgColor = 'rgba(255,0,0,0.25)';\n//                     else bgColor = 'rgba(255,255,0,0.35)';\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* PANEL */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\n"],"mappings":"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AAHpG,GAAG;AAwQZ,eAAeA,GAAG;;AAElB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA,IAAAoG,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}