{"ast":null,"code":"var _jsxFileName = \"/home/n/semantic_map_ui/src/App.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from \"react\";\n\n/* ===== MAP PARAMS ===== */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_SIZE = 20;\nconst MAP_SIZE = 800;\nconst GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n/* ===== UTIL ===== */\nconst rectFill = points => {\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const cells = [];\n  for (let x = minX; x <= maxX; x++) {\n    for (let y = minY; y <= maxY; y++) {\n      cells.push({\n        x,\n        y\n      });\n    }\n  }\n  return {\n    cells,\n    minX,\n    maxX,\n    minY,\n    maxY\n  };\n};\nfunction App() {\n  _s();\n  /* ===== STATE ===== */\n  const [task, setTask] = useState(null);\n  // 'set_origin' | 'define_place' | 'define_object' | 'tosm'\n\n  const [origin, setOrigin] = useState(null);\n  const [gridMap, setGridMap] = useState({});\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [polygonPoints, setPolygonPoints] = useState([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const draggedRef = useRef(false);\n\n  /* ===== JSON LOAD ===== */\n  useEffect(() => {\n    fetch(\"/semantic_grid_map.json\").then(res => res.ok ? res.json() : null).then(data => {\n      if (data !== null && data !== void 0 && data.grid) setGridMap(data.grid);\n    });\n  }, []);\n\n  /* ===== GRID UTILS ===== */\n  const getGridFromMouse = e => {\n    const rect = e.currentTarget.getBoundingClientRect();\n    return {\n      gx: Math.floor((e.clientX - rect.left) / GRID_SIZE),\n      gy: Math.floor((e.clientY - rect.top) / GRID_SIZE)\n    };\n  };\n  const toggleCell = (x, y) => {\n    setSelectedCells(prev => {\n      const exists = prev.some(c => c.x === x && c.y === y);\n      return exists ? prev.filter(c => !(c.x === x && c.y === y)) : [...prev, {\n        x,\n        y\n      }];\n    });\n  };\n  const addCell = (x, y) => {\n    setSelectedCells(prev => prev.some(c => c.x === x && c.y === y) ? prev : [...prev, {\n      x,\n      y\n    }]);\n  };\n\n  /* ===== TASK HANDLER ===== */\n  const handleGridAction = (x, y) => {\n    if (task === \"set_origin\") {\n      if (origin) {\n        alert(\"Ï§ëÏã¨Ï¢åÌëúÎäî Ïù¥ÎØ∏ ÏÑ§Ï†ïÎê®\");\n        return;\n      }\n      setOrigin({\n        x,\n        y\n      });\n      setTask(null);\n      return;\n    }\n    if (task === \"define_place\" || task === \"define_object\") {\n      setPolygonPoints(prev => {\n        if (prev.length >= 4) return prev;\n        return [...prev, {\n          x,\n          y\n        }];\n      });\n      return;\n    }\n\n    // Í∏∞Î≥∏ ÏÑ†ÌÉù Î™®Îìú\n    toggleCell(x, y);\n  };\n\n  /* ===== APPLY PLACE (POLYGON) ===== */\n  useEffect(() => {\n    if (task !== \"define_place\") return;\n    if (polygonPoints.length !== 4) return;\n    const name = prompt(\"place name?\");\n    if (!name) return;\n    const {\n      cells\n    } = rectFill(polygonPoints);\n    setGridMap(prev => {\n      const updated = {\n        ...prev\n      };\n      cells.forEach(({\n        x,\n        y\n      }) => {\n        updated[`${x},${y}`] = {\n          places: [{\n            id: name,\n            type: \"place\",\n            explicit: {\n              grid: {\n                x,\n                y\n              }\n            },\n            implicit: {},\n            symbolic: {\n              label: name\n            }\n          }],\n          objects: [],\n          robots: []\n        };\n      });\n      return updated;\n    });\n    setPolygonPoints([]);\n    setTask(null);\n  }, [polygonPoints, task]);\n\n  /* ===== APPLY OBJECT (POLYGON) ===== */\n  useEffect(() => {\n    if (task !== \"define_object\") return;\n    if (polygonPoints.length !== 4) return;\n    const {\n      cells,\n      minX,\n      maxX,\n      minY,\n      maxY\n    } = rectFill(polygonPoints);\n\n    // place Í≤ÄÏ¶ù\n    const invalid = cells.some(({\n      x,\n      y\n    }) => {\n      var _gridMap, _gridMap$places;\n      return !((_gridMap = gridMap[`${x},${y}`]) !== null && _gridMap !== void 0 && (_gridMap$places = _gridMap.places) !== null && _gridMap$places !== void 0 && _gridMap$places.length);\n    });\n    if (invalid) {\n      alert(\"Í≥µÍ∞Ñ(place) Î®ºÏ†Ä ÏßÄÏ†ïÌïòÏÑ∏Ïöî\");\n      setPolygonPoints([]);\n      setTask(null);\n      return;\n    }\n    const id = prompt(\"object id?\");\n    const type = prompt(\"object type?\");\n    if (!id || !type) return;\n    const center = {\n      x: (minX + maxX) / 2,\n      y: (minY + maxY) / 2\n    };\n    setGridMap(prev => {\n      const updated = {\n        ...prev\n      };\n      cells.forEach(({\n        x,\n        y\n      }) => {\n        const cell = updated[`${x},${y}`];\n        updated[`${x},${y}`] = {\n          ...cell,\n          objects: [{\n            id,\n            type,\n            explicit: {\n              center\n            },\n            implicit: {},\n            symbolic: {\n              label: type\n            }\n          }]\n        };\n      });\n      return updated;\n    });\n    setPolygonPoints([]);\n    setTask(null);\n  }, [polygonPoints, task, gridMap]);\n\n  /* ===== RENDER ===== */\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      display: \"flex\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        width: MAP_SIZE,\n        height: MAP_SIZE,\n        position: \"relative\",\n        border: \"1px solid black\",\n        background: \"#eee\"\n      },\n      onMouseDown: e => {\n        draggedRef.current = false;\n        setIsDragging(true);\n        const {\n          gx,\n          gy\n        } = getGridFromMouse(e);\n        handleGridAction(gx, gy);\n      },\n      onMouseMove: e => {\n        if (!isDragging) return;\n        draggedRef.current = true;\n        const {\n          gx,\n          gy\n        } = getGridFromMouse(e);\n        addCell(gx, gy);\n      },\n      onMouseUp: e => {\n        setIsDragging(false);\n        if (!draggedRef.current) {\n          const {\n            gx,\n            gy\n          } = getGridFromMouse(e);\n          handleGridAction(gx, gy);\n        }\n      },\n      onMouseLeave: () => setIsDragging(false),\n      children: [[...Array(GRID_COUNT)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          left: i * GRID_SIZE,\n          top: 0,\n          width: 1,\n          height: \"100%\",\n          background: \"rgba(0,0,0,0.2)\"\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 215,\n        columnNumber: 11\n      }, this)), [...Array(GRID_COUNT)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          top: i * GRID_SIZE,\n          left: 0,\n          height: 1,\n          width: \"100%\",\n          background: \"rgba(0,0,0,0.2)\"\n        }\n      }, `h${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 225,\n        columnNumber: 11\n      }, this)), Object.entries(gridMap).map(([key, val]) => {\n        var _val$places;\n        if (!((_val$places = val.places) !== null && _val$places !== void 0 && _val$places.length)) return null;\n        const [x, y] = key.split(\",\").map(Number);\n        const isWall = val.places[0].id === \"wall\";\n        const hasObject = val.objects.length > 0;\n        let bg = \"rgba(255,255,0,0.3)\";\n        if (hasObject) bg = \"rgba(255,0,0,0.3)\";\n        if (isWall) bg = \"rgba(0,0,0,0.4)\";\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            position: \"absolute\",\n            left: x * GRID_SIZE,\n            top: y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            background: bg,\n            pointerEvents: \"none\"\n          }\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 247,\n          columnNumber: 13\n        }, this);\n      }), selectedCells.map(({\n        x,\n        y\n      }) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          left: x * GRID_SIZE,\n          top: y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: \"rgba(0,0,255,0.3)\",\n          pointerEvents: \"none\"\n        }\n      }, `${x},${y}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 261,\n        columnNumber: 11\n      }, this)), polygonPoints.map(({\n        x,\n        y\n      }, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          left: x * GRID_SIZE,\n          top: y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: \"rgba(128,0,255,0.5)\",\n          pointerEvents: \"none\"\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 274,\n        columnNumber: 11\n      }, this)), origin && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          left: origin.x * GRID_SIZE,\n          top: origin.y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          border: \"2px solid red\",\n          pointerEvents: \"none\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 287,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginLeft: 20,\n        width: 300\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Tools\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 301,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setTask(\"set_origin\"),\n        children: \"\\uC911\\uC2EC\\uC88C\\uD45C \\uC124\\uC815\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 302,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 302,\n        columnNumber: 71\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setTask(\"define_place\");\n          setPolygonPoints([]);\n        },\n        children: \"\\uACF5\\uAC04(place) \\uC9C0\\uC815\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 305,\n        columnNumber: 18\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setTask(\"define_object\");\n          setPolygonPoints([]);\n        },\n        children: \"\\uC624\\uBE0C\\uC81D\\uD2B8(object) \\uC9C0\\uC815\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 306,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 308,\n        columnNumber: 18\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setTask(\"tosm\"),\n        children: \"TOSM \\uC785\\uB825\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        style: {\n          height: 500,\n          overflow: \"auto\"\n        },\n        children: JSON.stringify({\n          origin,\n          grid: gridMap\n        }, null, 2)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 311,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 300,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 182,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"d8J3JF4i3yyo85RDLKh9XU45/qc=\");\n_c = App;\nexport default App;\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 20;\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT (y desc ‚Üí x desc) ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK (ÏÑ†ÌÉùÎßå Îã¥Îãπ) ===== */\n//     const handleGridClick = (gx, gy) => {\n//         const exists = selectedCells.some((c) => c.x === gx && c.y === gy);\n\n//         if (exists) {\n//             setSelectedCells((prev) =>\n//                 prev.filter((c) => !(c.x === gx && c.y === gy))\n//             );\n//         } else {\n//             setSelectedCells((prev) => [...prev, { x: gx, y: gy }]);\n//         }\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ], // ‚úÖ ÎçÆÏñ¥Ïì∞Í∏∞\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ], // ‚úÖ ÎçÆÏñ¥Ïì∞Í∏∞\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_SIZE,\n//                     height: MAP_SIZE,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_SIZE}px ${MAP_SIZE}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true; // ‚≠ê ÎìúÎûòÍ∑∏ Î∞úÏÉù Í∏∞Î°ù\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     // ‚≠ê ÎìúÎûòÍ∑∏ Ïïà ÌñàÏùÑ ÎïåÎßå toggle\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COUNT)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n//                 {[...Array(GRID_COUNT)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n\n//                     const place = val.places[0]; // ÌòÑÏû¨ ÏÖÄÏùò ÎåÄÌëú place\n//                     const hasObject = val.objects && val.objects.length > 0;\n//                     const isPath = place.id === 'path';\n//                     const isWall = place.id === 'wall';\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n\n//                     if (isPath) {\n//                         bgColor = 'rgba(0,255,0,0.25)'; // üü¢\n//                     } else if (hasObject || isWall) {\n//                         bgColor = 'rgba(255,0,0,0.25)'; // üî¥\n//                     } else if (!hasObject) {\n//                         bgColor = 'rgba(255,255,0,0.35)'; // üü°\n//                     }\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* ===== PANEL ===== */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useState","useRef","jsxDEV","_jsxDEV","GRID_SIZE","MAP_SIZE","GRID_COUNT","rectFill","points","xs","map","p","x","ys","y","minX","Math","min","maxX","max","minY","maxY","cells","push","App","_s","task","setTask","origin","setOrigin","gridMap","setGridMap","selectedCells","setSelectedCells","polygonPoints","setPolygonPoints","isDragging","setIsDragging","draggedRef","fetch","then","res","ok","json","data","grid","getGridFromMouse","e","rect","currentTarget","getBoundingClientRect","gx","floor","clientX","left","gy","clientY","top","toggleCell","prev","exists","some","c","filter","addCell","handleGridAction","alert","length","name","prompt","updated","forEach","places","id","type","explicit","implicit","symbolic","label","objects","robots","invalid","_gridMap","_gridMap$places","center","cell","style","display","children","width","height","position","border","background","onMouseDown","current","onMouseMove","onMouseUp","onMouseLeave","Array","_","i","fileName","_jsxFileName","lineNumber","columnNumber","Object","entries","key","val","_val$places","split","Number","isWall","hasObject","bg","pointerEvents","marginLeft","onClick","overflow","JSON","stringify","_c","$RefreshReg$"],"sources":["/home/n/semantic_map_ui/src/App.js"],"sourcesContent":["import { useEffect, useState, useRef } from \"react\";\n\n/* ===== MAP PARAMS ===== */\nconst GRID_SIZE = 20;\nconst MAP_SIZE = 800;\nconst GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n/* ===== UTIL ===== */\nconst rectFill = (points) => {\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n\n  const cells = [];\n  for (let x = minX; x <= maxX; x++) {\n    for (let y = minY; y <= maxY; y++) {\n      cells.push({ x, y });\n    }\n  }\n  return { cells, minX, maxX, minY, maxY };\n};\n\nfunction App() {\n  /* ===== STATE ===== */\n  const [task, setTask] = useState(null);\n  // 'set_origin' | 'define_place' | 'define_object' | 'tosm'\n\n  const [origin, setOrigin] = useState(null);\n  const [gridMap, setGridMap] = useState({});\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [polygonPoints, setPolygonPoints] = useState([]);\n\n  const [isDragging, setIsDragging] = useState(false);\n  const draggedRef = useRef(false);\n\n  /* ===== JSON LOAD ===== */\n  useEffect(() => {\n    fetch(\"/semantic_grid_map.json\")\n      .then(res => res.ok ? res.json() : null)\n      .then(data => {\n        if (data?.grid) setGridMap(data.grid);\n      });\n  }, []);\n\n  /* ===== GRID UTILS ===== */\n  const getGridFromMouse = (e) => {\n    const rect = e.currentTarget.getBoundingClientRect();\n    return {\n      gx: Math.floor((e.clientX - rect.left) / GRID_SIZE),\n      gy: Math.floor((e.clientY - rect.top) / GRID_SIZE),\n    };\n  };\n\n  const toggleCell = (x, y) => {\n    setSelectedCells(prev => {\n      const exists = prev.some(c => c.x === x && c.y === y);\n      return exists\n        ? prev.filter(c => !(c.x === x && c.y === y))\n        : [...prev, { x, y }];\n    });\n  };\n\n  const addCell = (x, y) => {\n    setSelectedCells(prev =>\n      prev.some(c => c.x === x && c.y === y)\n        ? prev\n        : [...prev, { x, y }]\n    );\n  };\n\n  /* ===== TASK HANDLER ===== */\n  const handleGridAction = (x, y) => {\n    if (task === \"set_origin\") {\n      if (origin) {\n        alert(\"Ï§ëÏã¨Ï¢åÌëúÎäî Ïù¥ÎØ∏ ÏÑ§Ï†ïÎê®\");\n        return;\n      }\n      setOrigin({ x, y });\n      setTask(null);\n      return;\n    }\n\n    if (task === \"define_place\" || task === \"define_object\") {\n      setPolygonPoints(prev => {\n        if (prev.length >= 4) return prev;\n        return [...prev, { x, y }];\n      });\n      return;\n    }\n\n    // Í∏∞Î≥∏ ÏÑ†ÌÉù Î™®Îìú\n    toggleCell(x, y);\n  };\n\n  /* ===== APPLY PLACE (POLYGON) ===== */\n  useEffect(() => {\n    if (task !== \"define_place\") return;\n    if (polygonPoints.length !== 4) return;\n\n    const name = prompt(\"place name?\");\n    if (!name) return;\n\n    const { cells } = rectFill(polygonPoints);\n\n    setGridMap(prev => {\n      const updated = { ...prev };\n      cells.forEach(({ x, y }) => {\n        updated[`${x},${y}`] = {\n          places: [{\n            id: name,\n            type: \"place\",\n            explicit: { grid: { x, y } },\n            implicit: {},\n            symbolic: { label: name }\n          }],\n          objects: [],\n          robots: []\n        };\n      });\n      return updated;\n    });\n\n    setPolygonPoints([]);\n    setTask(null);\n  }, [polygonPoints, task]);\n\n  /* ===== APPLY OBJECT (POLYGON) ===== */\n  useEffect(() => {\n    if (task !== \"define_object\") return;\n    if (polygonPoints.length !== 4) return;\n\n    const { cells, minX, maxX, minY, maxY } = rectFill(polygonPoints);\n\n    // place Í≤ÄÏ¶ù\n    const invalid = cells.some(({ x, y }) =>\n      !gridMap[`${x},${y}`]?.places?.length\n    );\n    if (invalid) {\n      alert(\"Í≥µÍ∞Ñ(place) Î®ºÏ†Ä ÏßÄÏ†ïÌïòÏÑ∏Ïöî\");\n      setPolygonPoints([]);\n      setTask(null);\n      return;\n    }\n\n    const id = prompt(\"object id?\");\n    const type = prompt(\"object type?\");\n    if (!id || !type) return;\n\n    const center = {\n      x: (minX + maxX) / 2,\n      y: (minY + maxY) / 2\n    };\n\n    setGridMap(prev => {\n      const updated = { ...prev };\n      cells.forEach(({ x, y }) => {\n        const cell = updated[`${x},${y}`];\n        updated[`${x},${y}`] = {\n          ...cell,\n          objects: [{\n            id,\n            type,\n            explicit: { center },\n            implicit: {},\n            symbolic: { label: type }\n          }]\n        };\n      });\n      return updated;\n    });\n\n    setPolygonPoints([]);\n    setTask(null);\n  }, [polygonPoints, task, gridMap]);\n\n  /* ===== RENDER ===== */\n  return (\n    <div style={{ display: \"flex\" }}>\n      {/* MAP */}\n      <div\n        style={{\n          width: MAP_SIZE,\n          height: MAP_SIZE,\n          position: \"relative\",\n          border: \"1px solid black\",\n          background: \"#eee\"\n        }}\n        onMouseDown={e => {\n          draggedRef.current = false;\n          setIsDragging(true);\n          const { gx, gy } = getGridFromMouse(e);\n          handleGridAction(gx, gy);\n        }}\n        onMouseMove={e => {\n          if (!isDragging) return;\n          draggedRef.current = true;\n          const { gx, gy } = getGridFromMouse(e);\n          addCell(gx, gy);\n        }}\n        onMouseUp={e => {\n          setIsDragging(false);\n          if (!draggedRef.current) {\n            const { gx, gy } = getGridFromMouse(e);\n            handleGridAction(gx, gy);\n          }\n        }}\n        onMouseLeave={() => setIsDragging(false)}\n      >\n        {/* GRID */}\n        {[...Array(GRID_COUNT)].map((_, i) => (\n          <div key={i} style={{\n            position: \"absolute\",\n            left: i * GRID_SIZE,\n            top: 0,\n            width: 1,\n            height: \"100%\",\n            background: \"rgba(0,0,0,0.2)\"\n          }} />\n        ))}\n        {[...Array(GRID_COUNT)].map((_, i) => (\n          <div key={`h${i}`} style={{\n            position: \"absolute\",\n            top: i * GRID_SIZE,\n            left: 0,\n            height: 1,\n            width: \"100%\",\n            background: \"rgba(0,0,0,0.2)\"\n          }} />\n        ))}\n\n        {/* GRID VIS */}\n        {Object.entries(gridMap).map(([key, val]) => {\n          if (!val.places?.length) return null;\n          const [x, y] = key.split(\",\").map(Number);\n          const isWall = val.places[0].id === \"wall\";\n          const hasObject = val.objects.length > 0;\n\n          let bg = \"rgba(255,255,0,0.3)\";\n          if (hasObject) bg = \"rgba(255,0,0,0.3)\";\n          if (isWall) bg = \"rgba(0,0,0,0.4)\";\n\n          return (\n            <div key={key} style={{\n              position: \"absolute\",\n              left: x * GRID_SIZE,\n              top: y * GRID_SIZE,\n              width: GRID_SIZE,\n              height: GRID_SIZE,\n              background: bg,\n              pointerEvents: \"none\"\n            }} />\n          );\n        })}\n\n        {/* SELECTED */}\n        {selectedCells.map(({ x, y }) => (\n          <div key={`${x},${y}`} style={{\n            position: \"absolute\",\n            left: x * GRID_SIZE,\n            top: y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            background: \"rgba(0,0,255,0.3)\",\n            pointerEvents: \"none\"\n          }} />\n        ))}\n\n        {/* POLYGON POINTS */}\n        {polygonPoints.map(({ x, y }, i) => (\n          <div key={i} style={{\n            position: \"absolute\",\n            left: x * GRID_SIZE,\n            top: y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            background: \"rgba(128,0,255,0.5)\",\n            pointerEvents: \"none\"\n          }} />\n        ))}\n\n        {/* ORIGIN */}\n        {origin && (\n          <div style={{\n            position: \"absolute\",\n            left: origin.x * GRID_SIZE,\n            top: origin.y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            border: \"2px solid red\",\n            pointerEvents: \"none\"\n          }} />\n        )}\n      </div>\n\n      {/* PANEL */}\n      <div style={{ marginLeft: 20, width: 300 }}>\n        <h3>Tools</h3>\n        <button onClick={() => setTask(\"set_origin\")}>Ï§ëÏã¨Ï¢åÌëú ÏÑ§Ï†ï</button><br />\n        <button onClick={() => { setTask(\"define_place\"); setPolygonPoints([]); }}>\n          Í≥µÍ∞Ñ(place) ÏßÄÏ†ï\n        </button><br />\n        <button onClick={() => { setTask(\"define_object\"); setPolygonPoints([]); }}>\n          Ïò§Î∏åÏ†ùÌä∏(object) ÏßÄÏ†ï\n        </button><br />\n        <button onClick={() => setTask(\"tosm\")}>TOSM ÏûÖÎ†•</button>\n\n        <pre style={{ height: 500, overflow: \"auto\" }}>\n          {JSON.stringify({ origin, grid: gridMap }, null, 2)}\n        </pre>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 20;\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT (y desc ‚Üí x desc) ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK (ÏÑ†ÌÉùÎßå Îã¥Îãπ) ===== */\n//     const handleGridClick = (gx, gy) => {\n//         const exists = selectedCells.some((c) => c.x === gx && c.y === gy);\n\n//         if (exists) {\n//             setSelectedCells((prev) =>\n//                 prev.filter((c) => !(c.x === gx && c.y === gy))\n//             );\n//         } else {\n//             setSelectedCells((prev) => [...prev, { x: gx, y: gy }]);\n//         }\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ], // ‚úÖ ÎçÆÏñ¥Ïì∞Í∏∞\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ], // ‚úÖ ÎçÆÏñ¥Ïì∞Í∏∞\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_SIZE,\n//                     height: MAP_SIZE,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_SIZE}px ${MAP_SIZE}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true; // ‚≠ê ÎìúÎûòÍ∑∏ Î∞úÏÉù Í∏∞Î°ù\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     // ‚≠ê ÎìúÎûòÍ∑∏ Ïïà ÌñàÏùÑ ÎïåÎßå toggle\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COUNT)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n//                 {[...Array(GRID_COUNT)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n\n//                     const place = val.places[0]; // ÌòÑÏû¨ ÏÖÄÏùò ÎåÄÌëú place\n//                     const hasObject = val.objects && val.objects.length > 0;\n//                     const isPath = place.id === 'path';\n//                     const isWall = place.id === 'wall';\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n\n//                     if (isPath) {\n//                         bgColor = 'rgba(0,255,0,0.25)'; // üü¢\n//                     } else if (hasObject || isWall) {\n//                         bgColor = 'rgba(255,0,0,0.25)'; // üî¥\n//                     } else if (!hasObject) {\n//                         bgColor = 'rgba(255,255,0,0.35)'; // üü°\n//                     }\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* ===== PANEL ===== */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\n"],"mappings":"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A;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA,IAAAkG,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}