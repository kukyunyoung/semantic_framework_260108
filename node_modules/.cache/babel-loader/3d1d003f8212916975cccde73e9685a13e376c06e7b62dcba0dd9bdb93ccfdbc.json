{"ast":null,"code":"var _jsxFileName = \"/home/n/semantic_map_ui/src/App.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\n\n/* ===== MAP PARAMS ===== */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_SIZE = 5;\nconst GRID_COLS = 145;\nconst GRID_ROWS = 102;\nconst MAP_WIDTH = GRID_COLS * GRID_SIZE;\nconst MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\nfunction App() {\n  _s();\n  const [mode, setMode] = useState('place');\n  const [gridMap, setGridMap] = useState({});\n  const [cornerPoints, setCornerPoints] = useState([]);\n  const [selectedCells, setSelectedCells] = useState([]);\n\n  /* ===== JSON LOAD ===== */\n  useEffect(() => {\n    fetch('/semantic_grid_map.json').then(res => res.ok ? res.json() : null).then(data => (data === null || data === void 0 ? void 0 : data.grid) && setGridMap(data.grid)).catch(() => {});\n  }, []);\n\n  /* ===== MAP CLICK (4 POINTS ONLY) ===== */\n  const handleMapClick = e => {\n    if (cornerPoints.length >= 4) return;\n    const rect = e.currentTarget.getBoundingClientRect();\n    const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n    const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n    setCornerPoints(prev => [...prev, {\n      x: gx,\n      y: gy\n    }]);\n  };\n\n  /* ===== WHEN 4 POINTS SELECTED → AUTO SELECT AREA ===== */\n  useEffect(() => {\n    if (cornerPoints.length !== 4) return;\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n    const cells = [];\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        cells.push({\n          x,\n          y\n        });\n      }\n    }\n    setSelectedCells(cells);\n  }, [cornerPoints]);\n\n  /* ===== APPLY (PLACE / OBJECT) ===== */\n  const applyToSelected = () => {\n    if (cornerPoints.length !== 4 || selectedCells.length === 0) {\n      alert('점 4개를 먼저 찍어라');\n      return;\n    }\n    const name = prompt(mode === 'place' ? 'place name?' : 'object id?');\n    const type = mode === 'object' ? prompt('object type?') : 'place';\n    const relation = prompt('relation?');\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n    const center = {\n      x: (Math.min(...xs) + Math.max(...xs)) / 2,\n      y: (Math.min(...ys) + Math.max(...ys)) / 2\n    };\n    setGridMap(prev => {\n      const updated = {\n        ...prev\n      };\n      selectedCells.forEach(({\n        x,\n        y\n      }) => {\n        const key = `${x},${y}`;\n        const cell = updated[key] || {\n          places: [],\n          objects: [],\n          robots: []\n        };\n        if (mode === 'place') {\n          cell.places = [{\n            id: name,\n            type: 'place',\n            explicit: {\n              grid: center\n            },\n            implicit: {\n              relation: relation || 'none'\n            },\n            symbolic: {\n              label: name\n            }\n          }];\n        } else {\n          cell.objects = [{\n            id: name,\n            type,\n            explicit: {\n              grid: center\n            },\n            implicit: {\n              relation: relation || 'none'\n            },\n            symbolic: {\n              label: type\n            }\n          }];\n        }\n        updated[key] = cell;\n      });\n      return updated;\n    });\n    setCornerPoints([]);\n    setSelectedCells([]);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      display: 'flex'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        width: MAP_WIDTH,\n        height: MAP_HEIGHT,\n        backgroundImage: \"url('/map.png')\",\n        backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n        position: 'relative',\n        border: '1px solid black'\n      },\n      onClick: handleMapClick,\n      children: [[...Array(GRID_COLS + 1)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: i * GRID_SIZE,\n          top: 0,\n          width: 1,\n          height: '100%',\n          background: 'rgba(0,0,0,0.2)'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 133,\n        columnNumber: 11\n      }, this)), [...Array(GRID_ROWS + 1)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: i * GRID_SIZE,\n          left: 0,\n          height: 1,\n          width: '100%',\n          background: 'rgba(0,0,0,0.2)'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 143,\n        columnNumber: 11\n      }, this)), selectedCells.map(({\n        x,\n        y\n      }) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: x * GRID_SIZE,\n          top: y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: 'rgba(0,0,255,0.3)',\n          pointerEvents: 'none'\n        }\n      }, `${x},${y}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 11\n      }, this)), cornerPoints.map((p, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: p.x * GRID_SIZE,\n          top: p.y * GRID_SIZE,\n          width: GRID_SIZE,\n          height: GRID_SIZE,\n          background: 'rgba(255,0,0,0.7)',\n          pointerEvents: 'none'\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 168,\n        columnNumber: 11\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginLeft: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Mode\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 182,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setMode('place'),\n        children: \"Place\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setMode('object'),\n        children: \"Object\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 184,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"\\uC810 \", cornerPoints.length, \" / 4 \\uC120\\uD0DD\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 186,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: applyToSelected,\n        children: \"Apply to Selected Cells\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 188,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        style: {\n          height: 600,\n          overflow: 'auto'\n        },\n        children: JSON.stringify({\n          grid: gridMap\n        }, null, 2)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 192,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 118,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ghD6mf40iX/1vNPA1r/3Mne33z0=\");\n_c = App;\nexport default App;\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 5;\n// const GRID_COLS = 145; // 가로\n// const GRID_ROWS = 102; // 세로\n\n// const MAP_WIDTH = GRID_COLS * GRID_SIZE;\n// const MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK ===== */\n//     const handleGridClick = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             const exists = prev.some((c) => c.x === gx && c.y === gy);\n//             return exists\n//                 ? prev.filter((c) => !(c.x === gx && c.y === gy))\n//                 : [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_WIDTH,\n//                     height: MAP_HEIGHT,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true;\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COLS + 1)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {[...Array(GRID_ROWS + 1)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n//                     const place = val.places[0];\n//                     const hasObject = val.objects && val.objects.length > 0;\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n//                     if (place.id === 'path') bgColor = 'rgba(0,255,0,0.25)';\n//                     else if (hasObject || place.id === 'wall')\n//                         bgColor = 'rgba(255,0,0,0.25)';\n//                     else bgColor = 'rgba(255,255,0,0.35)';\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* PANEL */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useState","jsxDEV","_jsxDEV","GRID_SIZE","GRID_COLS","GRID_ROWS","MAP_WIDTH","MAP_HEIGHT","App","_s","mode","setMode","gridMap","setGridMap","cornerPoints","setCornerPoints","selectedCells","setSelectedCells","fetch","then","res","ok","json","data","grid","catch","handleMapClick","e","length","rect","currentTarget","getBoundingClientRect","gx","Math","floor","clientX","left","gy","clientY","top","prev","x","y","xs","map","p","ys","minX","min","maxX","max","minY","maxY","cells","push","applyToSelected","alert","name","prompt","type","relation","center","updated","forEach","key","cell","places","objects","robots","id","explicit","implicit","symbolic","label","style","display","children","width","height","backgroundImage","backgroundSize","position","border","onClick","Array","_","i","background","fileName","_jsxFileName","lineNumber","columnNumber","pointerEvents","marginLeft","overflow","JSON","stringify","_c","$RefreshReg$"],"sources":["/home/n/semantic_map_ui/src/App.js"],"sourcesContent":["import { useEffect, useState } from 'react';\n\n/* ===== MAP PARAMS ===== */\nconst GRID_SIZE = 5;\nconst GRID_COLS = 145;\nconst GRID_ROWS = 102;\n\nconst MAP_WIDTH = GRID_COLS * GRID_SIZE;\nconst MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\nfunction App() {\n  const [mode, setMode] = useState('place');\n  const [gridMap, setGridMap] = useState({});\n  const [cornerPoints, setCornerPoints] = useState([]);\n  const [selectedCells, setSelectedCells] = useState([]);\n\n  /* ===== JSON LOAD ===== */\n  useEffect(() => {\n    fetch('/semantic_grid_map.json')\n      .then(res => (res.ok ? res.json() : null))\n      .then(data => data?.grid && setGridMap(data.grid))\n      .catch(() => {});\n  }, []);\n\n  /* ===== MAP CLICK (4 POINTS ONLY) ===== */\n  const handleMapClick = (e) => {\n    if (cornerPoints.length >= 4) return;\n\n    const rect = e.currentTarget.getBoundingClientRect();\n    const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n    const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n    setCornerPoints(prev => [...prev, { x: gx, y: gy }]);\n  };\n\n  /* ===== WHEN 4 POINTS SELECTED → AUTO SELECT AREA ===== */\n  useEffect(() => {\n    if (cornerPoints.length !== 4) return;\n\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    const cells = [];\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        cells.push({ x, y });\n      }\n    }\n\n    setSelectedCells(cells);\n  }, [cornerPoints]);\n\n  /* ===== APPLY (PLACE / OBJECT) ===== */\n  const applyToSelected = () => {\n    if (cornerPoints.length !== 4 || selectedCells.length === 0) {\n      alert('점 4개를 먼저 찍어라');\n      return;\n    }\n\n    const name = prompt(mode === 'place' ? 'place name?' : 'object id?');\n    const type =\n      mode === 'object' ? prompt('object type?') : 'place';\n    const relation = prompt('relation?');\n\n    const xs = cornerPoints.map(p => p.x);\n    const ys = cornerPoints.map(p => p.y);\n\n    const center = {\n      x: (Math.min(...xs) + Math.max(...xs)) / 2,\n      y: (Math.min(...ys) + Math.max(...ys)) / 2,\n    };\n\n    setGridMap(prev => {\n      const updated = { ...prev };\n\n      selectedCells.forEach(({ x, y }) => {\n        const key = `${x},${y}`;\n        const cell = updated[key] || {\n          places: [],\n          objects: [],\n          robots: [],\n        };\n\n        if (mode === 'place') {\n          cell.places = [{\n            id: name,\n            type: 'place',\n            explicit: { grid: center },\n            implicit: { relation: relation || 'none' },\n            symbolic: { label: name },\n          }];\n        } else {\n          cell.objects = [{\n            id: name,\n            type,\n            explicit: { grid: center },\n            implicit: { relation: relation || 'none' },\n            symbolic: { label: type },\n          }];\n        }\n\n        updated[key] = cell;\n      });\n\n      return updated;\n    });\n\n    setCornerPoints([]);\n    setSelectedCells([]);\n  };\n\n  return (\n    <div style={{ display: 'flex' }}>\n      {/* MAP */}\n      <div\n        style={{\n          width: MAP_WIDTH,\n          height: MAP_HEIGHT,\n          backgroundImage: \"url('/map.png')\",\n          backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n          position: 'relative',\n          border: '1px solid black',\n        }}\n        onClick={handleMapClick}\n      >\n        {/* GRID */}\n        {[...Array(GRID_COLS + 1)].map((_, i) => (\n          <div key={i} style={{\n            position: 'absolute',\n            left: i * GRID_SIZE,\n            top: 0,\n            width: 1,\n            height: '100%',\n            background: 'rgba(0,0,0,0.2)',\n          }} />\n        ))}\n        {[...Array(GRID_ROWS + 1)].map((_, i) => (\n          <div key={i} style={{\n            position: 'absolute',\n            top: i * GRID_SIZE,\n            left: 0,\n            height: 1,\n            width: '100%',\n            background: 'rgba(0,0,0,0.2)',\n          }} />\n        ))}\n\n        {/* SELECTED AREA */}\n        {selectedCells.map(({ x, y }) => (\n          <div key={`${x},${y}`} style={{\n            position: 'absolute',\n            left: x * GRID_SIZE,\n            top: y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            background: 'rgba(0,0,255,0.3)',\n            pointerEvents: 'none',\n          }} />\n        ))}\n\n        {/* CORNER POINTS */}\n        {cornerPoints.map((p, i) => (\n          <div key={i} style={{\n            position: 'absolute',\n            left: p.x * GRID_SIZE,\n            top: p.y * GRID_SIZE,\n            width: GRID_SIZE,\n            height: GRID_SIZE,\n            background: 'rgba(255,0,0,0.7)',\n            pointerEvents: 'none',\n          }} />\n        ))}\n      </div>\n\n      {/* PANEL */}\n      <div style={{ marginLeft: 20 }}>\n        <h3>Mode</h3>\n        <button onClick={() => setMode('place')}>Place</button>\n        <button onClick={() => setMode('object')}>Object</button>\n\n        <p>점 {cornerPoints.length} / 4 선택</p>\n\n        <button onClick={applyToSelected}>\n          Apply to Selected Cells\n        </button>\n\n        <pre style={{ height: 600, overflow: 'auto' }}>\n          {JSON.stringify({ grid: gridMap }, null, 2)}\n        </pre>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n\n// import { useEffect, useState, useRef } from 'react';\n\n// /* ===== MAP PARAMS ===== */\n// const GRID_SIZE = 5;\n// const GRID_COLS = 145; // 가로\n// const GRID_ROWS = 102; // 세로\n\n// const MAP_WIDTH = GRID_COLS * GRID_SIZE;\n// const MAP_HEIGHT = GRID_ROWS * GRID_SIZE;\n\n// const MAP_SIZE = 800;\n// const GRID_COUNT = MAP_SIZE / GRID_SIZE;\n\n// function App() {\n//     const [mode, setMode] = useState('place'); // place | object\n//     const [gridMap, setGridMap] = useState({});\n//     const [selectedCells, setSelectedCells] = useState([]);\n//     const [isDragging, setIsDragging] = useState(false);\n//     const draggedRef = useRef(false);\n\n//     /* ===== JSON LOAD ===== */\n//     useEffect(() => {\n//         fetch('/semantic_grid_map.json')\n//             .then((res) => (res.ok ? res.json() : null))\n//             .then((data) => {\n//                 if (data?.grid) setGridMap(data.grid);\n//             })\n//             .catch(() => console.log('no json'));\n//     }, []);\n\n//     /* ===== GRID SORT ===== */\n//     const sortGridDesc = (grid) => {\n//         return Object.fromEntries(\n//             Object.entries(grid).sort(([a], [b]) => {\n//                 const [ax, ay] = a.split(',').map(Number);\n//                 const [bx, by] = b.split(',').map(Number);\n//                 if (ay !== by) return by - ay;\n//                 return bx - ax;\n//             })\n//         );\n//     };\n\n//     /* ===== JSON SAVE ===== */\n//     const saveJSON = () => {\n//         const sortedGrid = sortGridDesc(gridMap);\n//         const blob = new Blob([JSON.stringify({ grid: sortedGrid }, null, 2)], {\n//             type: 'application/json',\n//         });\n//         const url = URL.createObjectURL(blob);\n//         const a = document.createElement('a');\n//         a.href = url;\n//         a.download = 'semantic_grid_map.json';\n//         a.click();\n//         URL.revokeObjectURL(url);\n//     };\n\n//     /* ===== GRID CLICK ===== */\n//     const handleGridClick = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             const exists = prev.some((c) => c.x === gx && c.y === gy);\n//             return exists\n//                 ? prev.filter((c) => !(c.x === gx && c.y === gy))\n//                 : [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     const addSelectedCell = (gx, gy) => {\n//         setSelectedCells((prev) => {\n//             if (prev.some((c) => c.x === gx && c.y === gy)) return prev;\n//             return [...prev, { x: gx, y: gy }];\n//         });\n//     };\n\n//     /* ===== APPLY PLACE ===== */\n//     const applyPlaceToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const name = prompt('place name?');\n//         const relation = prompt('relation?');\n//         if (!name) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key] || {\n//                     places: [],\n//                     objects: [],\n//                     robots: [],\n//                 };\n\n//                 updated[key] = {\n//                     ...cell,\n//                     places: [\n//                         {\n//                             id: name,\n//                             type: 'place',\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: name },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     /* ===== APPLY OBJECT ===== */\n//     const applyObjectToSelected = () => {\n//         if (selectedCells.length === 0) return;\n\n//         const id = prompt('object id?');\n//         const type = prompt('object type?');\n//         const relation = prompt('relation?');\n//         if (!id || !type) return;\n\n//         setGridMap((prev) => {\n//             const updated = { ...prev };\n\n//             selectedCells.forEach(({ x, y }) => {\n//                 const key = `${x},${y}`;\n//                 const cell = updated[key];\n//                 if (!cell || cell.places.length === 0) return;\n\n//                 updated[key] = {\n//                     ...cell,\n//                     objects: [\n//                         {\n//                             id,\n//                             type,\n//                             explicit: { grid: { x, y } },\n//                             implicit: { relation: relation || 'none' },\n//                             symbolic: { label: type },\n//                         },\n//                     ],\n//                 };\n//             });\n\n//             return updated;\n//         });\n\n//         setSelectedCells([]);\n//     };\n\n//     return (\n//         <div style={{ display: 'flex' }}>\n//             {/* MAP */}\n//             <div\n//                 style={{\n//                     width: MAP_WIDTH,\n//                     height: MAP_HEIGHT,\n//                     backgroundImage: \"url('/map.png')\",\n//                     backgroundSize: `${MAP_WIDTH}px ${MAP_HEIGHT}px`,\n//                     backgroundRepeat: 'no-repeat',\n//                     position: 'relative',\n//                     border: '1px solid black',\n//                 }}\n//                 onMouseDown={(e) => {\n//                     draggedRef.current = false;\n//                     setIsDragging(true);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseMove={(e) => {\n//                     if (!isDragging) return;\n\n//                     draggedRef.current = true;\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     addSelectedCell(gx, gy);\n//                 }}\n//                 onMouseUp={(e) => {\n//                     setIsDragging(false);\n\n//                     const rect = e.currentTarget.getBoundingClientRect();\n//                     const gx = Math.floor((e.clientX - rect.left) / GRID_SIZE);\n//                     const gy = Math.floor((e.clientY - rect.top) / GRID_SIZE);\n\n//                     if (!draggedRef.current) {\n//                         handleGridClick(gx, gy);\n//                     }\n//                 }}\n//                 onMouseLeave={() => {\n//                     setIsDragging(false);\n//                     draggedRef.current = false;\n//                 }}\n//             >\n//                 {/* GRID LINES */}\n//                 {[...Array(GRID_COLS + 1)].map((_, i) => (\n//                     <div\n//                         key={`v${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: i * GRID_SIZE,\n//                             top: 0,\n//                             width: 1,\n//                             height: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {[...Array(GRID_ROWS + 1)].map((_, i) => (\n//                     <div\n//                         key={`h${i}`}\n//                         style={{\n//                             position: 'absolute',\n//                             top: i * GRID_SIZE,\n//                             left: 0,\n//                             height: 1,\n//                             width: '100%',\n//                             background: 'rgba(0,0,0,0.2)',\n//                         }}\n//                     />\n//                 ))}\n\n//                 {/* PLACE / OBJECT VIS */}\n//                 {Object.entries(gridMap).map(([key, val]) => {\n//                     if (!val.places || val.places.length === 0) return null;\n\n//                     const [gx, gy] = key.split(',').map(Number);\n//                     const place = val.places[0];\n//                     const hasObject = val.objects && val.objects.length > 0;\n\n//                     let bgColor = 'rgba(255,255,255,0.0)';\n//                     if (place.id === 'path') bgColor = 'rgba(0,255,0,0.25)';\n//                     else if (hasObject || place.id === 'wall')\n//                         bgColor = 'rgba(255,0,0,0.25)';\n//                     else bgColor = 'rgba(255,255,0,0.35)';\n\n//                     return (\n//                         <div\n//                             key={key}\n//                             style={{\n//                                 position: 'absolute',\n//                                 left: gx * GRID_SIZE,\n//                                 top: gy * GRID_SIZE,\n//                                 width: GRID_SIZE,\n//                                 height: GRID_SIZE,\n//                                 background: bgColor,\n//                                 pointerEvents: 'none',\n//                             }}\n//                         />\n//                     );\n//                 })}\n\n//                 {/* SELECTED VIS */}\n//                 {selectedCells.map(({ x, y }) => (\n//                     <div\n//                         key={`sel-${x},${y}`}\n//                         style={{\n//                             position: 'absolute',\n//                             left: x * GRID_SIZE,\n//                             top: y * GRID_SIZE,\n//                             width: GRID_SIZE,\n//                             height: GRID_SIZE,\n//                             background: 'rgba(0,0,255,0.35)',\n//                             pointerEvents: 'none',\n//                         }}\n//                     />\n//                 ))}\n//             </div>\n\n//             {/* PANEL */}\n//             <div style={{ marginLeft: 20, width: 420 }}>\n//                 <h3>Mode</h3>\n//                 <button onClick={() => setMode('place')}>Place</button>\n//                 <button onClick={() => setMode('object')}>Object</button>\n\n//                 <br />\n//                 <br />\n\n//                 <button\n//                     onClick={\n//                         mode === 'place'\n//                             ? applyPlaceToSelected\n//                             : applyObjectToSelected\n//                     }\n//                 >\n//                     Apply to Selected Cells\n//                 </button>\n\n//                 <button onClick={saveJSON} style={{ marginLeft: 10 }}>\n//                     Save JSON\n//                 </button>\n\n//                 <pre style={{ height: 600, overflow: 'auto' }}>\n//                     {JSON.stringify({ grid: gridMap }, null, 2)}\n//                 </pre>\n//             </div>\n//         </div>\n//     );\n// }\n\n// export default App;\n"],"mappings":"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AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA,IAAAyF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}